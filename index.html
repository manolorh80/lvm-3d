<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LVM • Curva ϕ(t) (Farris) • Three.js + LaTeX</title>

  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 18px; line-height: 1.35; }
    h2 { margin: 0 0 10px 0; }
    #layout { display: grid; grid-template-columns: 1.2fr 1fr; gap: 14px; align-items: start; }
    @media (max-width: 980px){ #layout { grid-template-columns: 1fr; } }

    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; background: #fff; }
    #scene { width: 100%; height: 520px; border: 1px solid #ddd; border-radius: 12px; overflow: hidden; background: #0b0b0b; }

    .row { display: grid; grid-template-columns: 92px 1fr 58px; gap: 10px; align-items: center; margin: 8px 0; }
    input[type="range"]{ width: 100%; }
    code { background:#f3f3f3; padding:2px 6px; border-radius:6px; }
    .small { font-size: 0.92rem; opacity: 0.9; }
    .note { font-size: 0.9rem; opacity: 0.85; }
    .pill { display:inline-block; border:1px solid #ddd; border-radius:999px; padding:4px 10px; margin-right:6px; font-size:0.9rem; }
  </style>

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)']], displayMath: [['\\[','\\]']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <h2>LVM: curva \(\varphi(t)\) (interativa)</h2>

  <div id="layout">
    <div class="card">
      <div class="small">
        A curva é definida por
        \[
          \varphi(t)=\frac{1}{1+g}\Big((1+g-d)(\cos t,\sin t)+d(\cos(gt),\sin(gt))\Big),\quad t\in[0,2\pi].
        \]
      </div>

      <div style="margin-top:10px">
        <span class="pill">curva</span>
        <span class="pill">ponto \(\varphi(t)\)</span>
        <span class="pill">tangente</span>
      </div>

      <div class="row">
        <div><b>g</b></div>
        <input id="g" type="range" min="1" max="12" step="1" value="5">
        <div id="gVal">5</div>
      </div>

      <div class="row">
        <div><b>d</b></div>
        <input id="d" type="range" min="0" max="3" step="0.01" value="1.00">
        <div id="dVal">1.00</div>
      </div>

      <div class="row">
        <div><b>N</b></div>
        <input id="N" type="range" min="200" max="4000" step="50" value="1200">
        <div id="NVal">1200</div>
      </div>

      <div class="row">
        <div><b>t</b></div>
        <input id="t" type="range" min="0" max="6.283185307179586" step="0.001" value="0.0">
        <div id="tVal">0.000</div>
      </div>

      <div class="note">
        Dica: aumente \(N\) para suavizar; varie \(g\) para ver mudanças na simetria.
      </div>
    </div>

    <div id="scene" aria-label="Cena 3D"></div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ---------- UI ----------
    const gEl = document.getElementById("g");
    const dEl = document.getElementById("d");
    const NEl = document.getElementById("N");
    const tEl = document.getElementById("t");

    const gVal = document.getElementById("gVal");
    const dVal = document.getElementById("dVal");
    const NVal = document.getElementById("NVal");
    const tVal = document.getElementById("tVal");

    function syncLabels(){
      gVal.textContent = String(parseInt(gEl.value, 10));
      dVal.textContent = Number(dEl.value).toFixed(2);
      NVal.textContent = String(parseInt(NEl.value, 10));
      tVal.textContent = Number(tEl.value).toFixed(3);
    }

    // ---------- Math: φ(t) ----------
    function phi(t, g, d){
      const denom = 1 + g;
      const a = (1 + g - d);
      const x = (a*Math.cos(t) + d*Math.cos(g*t))/denom;
      const y = (a*Math.sin(t) + d*Math.sin(g*t))/denom;
      return new THREE.Vector3(x, y, 0);
    }

    // ---------- Three.js setup ----------
    const container = document.getElementById("scene");

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.01, 50);
    camera.position.set(0, 0, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    container.appendChild(renderer.domElement);

    // Simple light (MeshNormalMaterial doesn't need light, but future-proof)
    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(2, 3, 4);
    scene.add(light);

    // Axes (subtle)
    const axes = new THREE.AxesHelper(1.3);
    axes.material.transparent = true;
    axes.material.opacity = 0.35;
    scene.add(axes);

    // Grid in xy-plane
    const grid = new THREE.GridHelper(2.4, 12, 0x444444, 0x222222);
    grid.rotation.x = Math.PI/2;
    grid.material.transparent = true;
    grid.material.opacity = 0.35;
    scene.add(grid);

    // Curve line
    let curveLine = null;

    function buildCurve(){
      const g = parseInt(gEl.value, 10);
      const d = Number(dEl.value);
      const N = parseInt(NEl.value, 10);

      const pts = new Array(N+1);
      for(let i=0;i<=N;i++){
        const t = (2*Math.PI)*i/N;
        pts[i] = phi(t, g, d);
      }

      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat  = new THREE.LineBasicMaterial({ color: 0x7aa2ff });
      const line = new THREE.Line(geom, mat);
      return line;
    }

    function refreshCurve(){
      if(curveLine) scene.remove(curveLine);
      curveLine = buildCurve();
      scene.add(curveLine);
    }

    // Moving point on curve
    const pointGeom = new THREE.SphereGeometry(0.03, 24, 16);
    const pointMat  = new THREE.MeshStandardMaterial({ color: 0xffd166, emissive: 0x221100 });
    const movingPoint = new THREE.Mesh(pointGeom, pointMat);
    scene.add(movingPoint);

    // Tangent arrow
    const arrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 0.35, 0xff6b6b, 0.08, 0.05);
    scene.add(arrow);

    function updatePointAndTangent(){
      const g = parseInt(gEl.value, 10);
      const d = Number(dEl.value);
      const t = Number(tEl.value);

      const p = phi(t, g, d);
      movingPoint.position.copy(p);

      // finite difference tangent
      const h = 1e-3;
      const p2 = phi(t + h, g, d);
      const v = p2.clone().sub(p);
      const len = v.length();
      if(len > 1e-12) v.normalize();
      arrow.position.copy(p);
      arrow.setDirection(v);
      arrow.setLength(0.35, 0.08, 0.05);
    }

    // Orbit-like simple drag is extra; keep minimal and stable:
    let dragging = false;
    let lastX = 0, lastY = 0;
    let theta = 0, phiAng = 0; // camera spherical angles

    container.addEventListener("mousedown", (e)=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
    window.addEventListener("mouseup", ()=>{ dragging=false; });
    window.addEventListener("mousemove", (e)=>{
      if(!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;

      theta += dx * 0.005;
      phiAng += dy * 0.005;
      phiAng = Math.max(-1.2, Math.min(1.2, phiAng));
    });

    container.addEventListener("wheel", (e)=>{
      e.preventDefault();
      const z = camera.position.z;
      const nz = z + (e.deltaY * 0.002);
      camera.position.z = Math.max(1.3, Math.min(8.0, nz));
    }, { passive:false });

    function updateCamera(){
      const r = camera.position.z;
      const x = r * Math.sin(theta) * Math.cos(phiAng);
      const y = r * Math.sin(phiAng);
      const z = r * Math.cos(theta) * Math.cos(phiAng);
      camera.position.set(x, y, z);
      camera.lookAt(0,0,0);
    }

    function onResize(){
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    }
    window.addEventListener("resize", onResize);

    // ---------- Event wiring ----------
    function fullRefresh(){
      syncLabels();
      refreshCurve();
      updatePointAndTangent();
    }

    gEl.addEventListener("input", fullRefresh);
    dEl.addEventListener("input", fullRefresh);
    NEl.addEventListener("input", fullRefresh);
    tEl.addEventListener("input", ()=>{ syncLabels(); updatePointAndTangent(); });

    // init
    syncLabels();
    refreshCurve();
    updatePointAndTangent();
    onResize();

    function animate(){
      updateCamera();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
